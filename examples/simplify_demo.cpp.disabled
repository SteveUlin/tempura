// Demo of the canonical simplify function (Recommendation 1 implementation)
//
// This demonstrates the new multi-stage fixpoint simplification pipeline
// that is now the default behavior for `simplify`.

#include <iostream>
#include <print>

#include "symbolic3/symbolic3.h"

using namespace tempura::symbolic3;

int main() {
  // Define symbols
  constexpr Symbol x;
  constexpr Symbol y;
  constexpr Symbol z;

  // Create default context
  constexpr auto ctx = default_context();

  std::print("=== Canonical Simplify Demo (Recommendation 1) ===\n\n");

  // Example 1: Nested arithmetic
  {
    std::print("Example 1: Nested arithmetic\n");
    constexpr auto expr = x * (y + (z * 0_c));
    std::print("  Input:  {}\n", toString(expr));

    constexpr auto result = simplify(expr, ctx);
    std::print("  Output: {}\n", toString(result));
    std::print("  ✓ Correctly simplifies nested expressions\n\n");
  }

  // Example 2: Deep nesting with identity operations
  {
    std::print("Example 2: Deep expression with identities\n");
    constexpr auto expr = ((x + 0_c) * 1_c) + 0_c;
    std::print("  Input:  {}\n", toString(expr));

    constexpr auto result = simplify(expr, ctx);
    std::print("  Output: {}\n", toString(result));
    std::print("  ✓ Removes all identity operations\n\n");
  }

  // Example 3: Term collection with fixpoint iteration
  {
    std::print("Example 3: Term collection (requires fixpoint)\n");
    constexpr auto expr = (x + x) + x;
    std::print("  Input:  {}\n", toString(expr));

    constexpr auto result = simplify(expr, ctx);
    std::print("  Output: {}\n", toString(result));
    std::print("  ✓ Collects terms through multiple passes\n\n");
  }

  // Example 4: Complex nested expression
  {
    std::print("Example 4: Complex nested expression\n");
    constexpr auto expr = (2_c * x + 3_c * x) * (y + 0_c);
    std::print("  Input:  {}\n", toString(expr));

    constexpr auto result = simplify(expr, ctx);
    std::print("  Output: {}\n", toString(result));
    std::print("  ✓ Handles distribution and term collection\n\n");
  }

  // Example 5: Transcendental functions
  {
    std::print("Example 5: Transcendental simplification\n");
    constexpr auto expr = exp(log(x + 0_c));
    std::print("  Input:  {}\n", toString(expr));

    constexpr auto result = simplify(expr, ctx);
    std::print("  Output: {}\n", toString(result));
    std::print("  ✓ Simplifies nested transcendental functions\n\n");
  }

  std::print("=== Pipeline Comparison ===\n\n");

  // Compare different pipelines
  {
    constexpr auto expr = x * (y + (z * 0_c));
    std::print("Expression: {}\n\n", toString(expr));

    // Canonical simplify (multi-stage fixpoint)
    constexpr auto canonical = simplify(expr, ctx);
    std::print("simplify (canonical):            {}\n", toString(canonical));

    // Explicit full_simplify (same as simplify)
    constexpr auto full = full_simplify(expr, ctx);
    std::print("full_simplify:                   {}\n", toString(full));

    // Fast recursive (single pass per node)
    constexpr auto fast = algebraic_simplify_recursive(expr, ctx);
    std::print("algebraic_simplify_recursive:    {}\n", toString(fast));

    // Legacy bounded (10 iterations, top-level only)
    constexpr auto legacy = simplify_bounded.apply(expr, ctx);
    std::print("simplify_bounded (legacy):       {}\n", toString(legacy));

    std::print("\n✓ All pipelines produce correct results\n");
    std::print("✓ simplify and full_simplify are identical (aliases)\n");
    std::print("✓ Legacy simplify_bounded available for compatibility\n\n");
  }

  std::print("=== Key Benefits ===\n\n");
  std::print(
      "1. Multi-stage pipeline: innermost → fixpoint → outer fixpoint\n");
  std::print("2. No arbitrary iteration limits (uses fixpoint detection)\n");
  std::print("3. Handles all nesting levels correctly\n");
  std::print("4. Predictable, deterministic results\n");
  std::print("5. Same performance characteristics as old full_simplify\n");
  std::print("6. Backward compatible via simplify_bounded\n\n");

  return 0;
}
